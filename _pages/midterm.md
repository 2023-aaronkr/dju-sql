---
layout: page
title: Midterm Guide / 중간고사 가이드
permalink: /midterm/
---

{:toc}

---

1. [코딩 환경 설정](#1-코딩-환경-설정)
2. [데이타베이스와 테이블 생성](#2-데이타베이스와-테이블-생성)
3. [SELECT로 시작하는 데이터 탐험](#3-SELECT로-시작하는-데이터-탐험)
4. [데이터 타입 이해](#4-데이터-타입-이해)
5. [데이터 가져오고 내보내기](#5-데이터-가져오고-내보내기)
6. [SQL을 사용한 기본 수학 및 통계](#6-SQL을-사용한-기본-수학-및-통계)
7. [관계형 데이터베이스에서 테이블 조인](#7-관계형-데이터베이스에서-테이블-조인)

---

## 이 책에 대하여

1. SQL은 무엇인가?
2. 왜 SQL을 사용해야 할까?
3. 엑셀은 시트 하나당 최대 1,048,576개의 행을 생성할 수 있습니다.
4. 액세스는 데이터베이스 코개가 2GB로 제한되어 있고 테이블당 열을 255개까지만 생성할 수 있습니다.

## 1. 코딩 환경 설정

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

---

## 2. 데이타베이스와 테이블 생성

1. 테이블 이해
2. pgAdmin에서 SQL 실행

**테이블 생성**

```sql
CREATE DATABASE dju;
```

```sql
CREATE TABLE teachers (
  id bigserial, -- bigserial은 자동으로 증가하는 숫자를 생성합니다 (PostgreSQL에서만 사용 가능)
  first_name varchar(25), -- varchar는 가변 길이 문자열을 저장합니다 (예: 'Aaron')
  last_name varchar(50),
  school varchar(50),
  hire_date date, -- date는 날짜를 저장합니다 (예: YYYY-MM-DD)
  salary numeric -- numeric은 숫자를 저장합니다 (예: 123456.78)
);
```

**테이블에 행 삽입**

```sql
INSERT INTO teachers (first_name, last_name, school, hire_date, salary)
VALUES ('Aaron', 'Snowberger', 'Daejeon University', '2023-09-01', 10000),
        ('John', 'Doe', 'Daejeon University', '2023-09-01', 10000),
        ('Jane', 'Doe', 'Daejeon University', '2023-09-01', 10000);
```

**테이블 데이터 보기**

```sql
TABLE teachers; -- 테이블의 모든 열을 보여줍니다 (1번째 방법)

SELECT * FROM teachers; -- 테이블의 모든 열을 보여줍니다 (2번째 방법)
```

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

---

## 3. SELECT로 시작하는 데이터 탐험

**SELECT**

```sql
SELECT * FROM teachers; -- 테이블의 모든 열을 보여줍니다
```

**WHERE**

```sql
SELECT * FROM teachers
WHERE first_name = 'Aaron'; -- first_name이 'Aaron'인 행만 보여줍니다
```

**AND**

```sql
SELECT * FROM teachers
WHERE first_name = 'Aaron' AND last_name = 'Snowberger'; -- first_name이 'Aaron'이고 last_name이 'Snowberger'인 행만 보여줍니다
```

**OR**

```sql
SELECT * FROM teachers
WHERE first_name = 'Aaron' OR first_name = 'John'; -- first_name이 'Aaron'이거나 'John'인 행만 보여줍니다
```

**IN**

```sql
SELECT * FROM teachers
WHERE first_name IN ('Aaron', 'John'); -- first_name이 'Aaron'이거나 'John'인 행만 보여줍니다
```

**NOT**

```sql
SELECT * FROM teachers
WHERE first_name NOT IN ('Aaron', 'John'); -- first_name이 'Aaron'이거나 'John'이 아닌 행만 보여줍니다
```

**BETWEEN**

```sql
SELECT * FROM teachers
WHERE hire_date BETWEEN '2023-09-01' AND '2023-09-30'; -- hire_date가 '2023-09-01'과 '2023-09-30' 사이인 행만 보여줍니다
```

**LIKE**

```sql
SELECT * FROM teachers
WHERE first_name LIKE 'A%'; -- first_name이 'A'로 시작하는 행만 보여줍니다
```

**ILIKE**

```sql
SELECT * FROM teachers
WHERE first_name ILIKE 'a%'; -- first_name이 'a'로 시작하는 행만 보여줍니다 (대소문자 구분 없음)
```

**ORDER BY**

```sql
SELECT * FROM teachers
ORDER BY last_name; -- last_name을 오름차순으로 정렬합니다
```

```sql
SELECT * FROM teachers
ORDER BY last_name DESC; -- last_name을 내림차순으로 정렬합니다
```

**LIMIT**

```sql
SELECT * FROM teachers
LIMIT 2; -- 행을 2개만 보여줍니다
```

**DISTINCT**

```sql
SELECT DISTINCT school FROM teachers; -- school 열의 중복을 제거합니다
```

**COUNT**

```sql
SELECT COUNT(*) FROM teachers; -- 행의 개수를 세어줍니다
```

**SUM**

```sql
SELECT SUM(salary) FROM teachers; -- salary 열의 합을 구합니다
```

**AVG**

```sql
SELECT AVG(salary) FROM teachers; -- salary 열의 평균을 구합니다
```

**MIN**

```sql
SELECT MIN(salary) FROM teachers; -- salary 열의 최솟값을 구합니다
```

**MAX**

```sql
SELECT MAX(salary) FROM teachers; -- salary 열의 최댓값을 구합니다
```

**GROUP BY**

```sql
SELECT school, COUNT(*) FROM teachers
GROUP BY school; -- school 열의 중복을 제거하고 행의 개수를 세어줍니다
```

**HAVING**

```sql
SELECT school, COUNT(*) FROM teachers
GROUP BY school
HAVING COUNT(*) > 1; -- school 열의 중복을 제거하고 행의 개수가 1보다 큰 행만 보여줍니다
```

**AS**

```sql
SELECT school, COUNT(*) AS count FROM teachers
GROUP BY school
HAVING COUNT(*) > 1; -- school 열의 중복을 제거하고 행의 개수가 1보다 큰 행만 보여줍니다
```

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

---

## 4. 데이터 타입 이해

**데이터 타입**

**문자열**

- `char(n)` (입력한 n 에 따라 길)
- `varchar(n)` (최대 길이가 n)
- `text` (길이 제한이 없는 가변 길 (1GB 입니다))

**숫자**

정수

- `smallint` (2바이트)
- `integer` (4바이트)
- `bigint` (8바이트)

실수

- `numeric(10, 2)` (고정 소수점) - fixed point - 10자리 숫자 중 소수점 이하 2자리까지 정밀도
- `real` (부동 소수점) - single precision (소수점 이하 6자리까지 정밀도)
- `double precision` (부동 소수점) - double precision (소수점 이하 15자리까지 정밀도)

자동 증가

- `smallserial` (2바이트) _PostgreSQL에서만 사용 가능_
- `serial` (4바이트) _PostgreSQL에서만 사용 가능_
- `bigserial` (8바이트) _PostgreSQL에서만 사용 가능_
- `id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY;` 다른 데이터베이스에서는 이렇게 사용합니다

**날짜**

- `date` (YYYY-MM-DD) (예: '2023-09-01') = 4바이트
- `time` (HH:MM:SS) (예: '12:30:00') = 8바이트
- `timestamp` (YYYY-MM-DD HH:MM:SS) (예: '2023-09-01 12:30:00') = 8바이트
- `interval` (예: '1 day') = 16바이트
- 불리언

**JSON**

- `json` (JSON 데이터) = 키/값 쌍과 값 목록의 컬렉션으로 정보를 구성하는 데이터 형식
- `jsonb` (JSON 데이터) = json과 동일하지만, 데이터가 정렬되어 있습니다 (인덱성을 지원하므로 처리 속도가 빠릅니다)

**다른 타입**

- `boolean` (true/false)
- `enum` (열거형)
- `uuid` (UUID)
- `xml` (XML 데이터)
- `range` (범위)
- `geomtric` (기하학)
- `text search` (텍스트 검색)
- `cidr` (IPv4/IPv6 네트워크 주소)
- `inet` (IPv4/IPv6 호스트 주소)
- `macaddr` (MAC 주소)
- `bit` (비트열)
- `bit varying` (가변 비트열)
- `NULL` (데이터가 없음)

**데이터 타입 변환**

```sql
SELECT CAST('2023-09-01' AS date); -- 문자열을 날짜로 변환합니다
```

```sql
SELECT CAST('2023-09-01' AS date) + 1 AS tomorrow; -- 날짜에 1을 더하고 열의 이름을 'tomorrow'로 지정합니다
```

```sql
SELECT timestamp_column, CAST(timestamp_column AS varchar(10))
FROM data_time_types; -- timestamp_column 열을 문자열로 변환합니다

SELECT timestamp_column, timestamp_column::varchar(10)
FROM data_time_types; -- 위와 동일한 결과를 보여줍니다
```

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

---

## 5. 데이터 가져오고 내보내기

**데이터 가져오기**

```sql
CREATE TABLE teachers (
  id bigserial,
  first_name varchar(25),
  last_name varchar(50),
  school varchar(50),
  hire_date date,
  salary numeric
);

COPY teachers (first_name, last_name, school, hire_date, salary)
FROM '/Users/aaronkr/Desktop/teachers.csv'
WITH (FORMAT CSV, HEADER); -- CSV 파일을 테이블에 삽입합니다
```

**삭제하기**

```sql
DELETE FROM teachers; -- 테이블의 모든 행을 삭제합니다

DELETE FROM teachers
WHERE id = 1; -- id가 1인 행을 삭제합니다
```

**데이터 가져오기 및 WHERE**

```sql
COPY teachers (first_name, last_name, school, hire_date, salary)
FROM '/Users/aaronkr/Desktop/teachers.csv'
WITH (FORMAT CSV, HEADER)
WHERE salary > 10000; -- CSV 파일에서 salary가 10000보다 큰 행만 테이블에 삽입합니다
```

**감시 테이블 (안 배웠지만 유용합니다)**

```sql
 CREATE TEMPORARY TABLE supervisor_salaries_temp
    (LIKE supervisor_salaries INCLUDING ALL);

COPY supervisor_salaries_temp (town, supervisor, salary)
FROM 'C:\YourDirectory\supervisor_salaries.csv'
WITH (FORMAT CSV, HEADER);

INSERT INTO supervisor_salaries (town, county, supervisor, salary)
SELECT town, 'Mills', supervisor, salary
FROM supervisor_salaries_temp;

DROP TABLE supervisor_salaries_temp;
```

**데이터 내보내기**

```sql
COPY teachers (first_name, last_name, school, hire_date, salary)
TO '/Users/aaronkr/Desktop/teachers.txt'
WITH (FORMAT CSV, HEADER, DELIMITER '|'); -- 테이블의 모든 행을 CSV 파일로 내보냅니다
```

**데이터 내보내기 및 WHERE**

```sql
COPY teachers (first_name, last_name, school, hire_date, salary)
TO '/Users/aaronkr/Desktop/teachers.txt'
WITH (FORMAT CSV, HEADER, DELIMITER '|')
WHERE salary > 10000; -- 테이블에서 salary가 10000보다 큰 행만 CSV 파일로 내보냅니다
```

**데이터 내보내기 및 SELECT**

```sql
COPY (
  SELECT first_name, last_name
  FROM teachers
  WHERE first_name ILIKE 'a%'
  )
TO '/Users/aaronkr/Desktop/teachers.txt'
WITH (FORMAT CSV, HEADER, DELIMITER '|'); -- 테이블에서 salary가 10000보다 큰 행의 first_name과 last_name 열만 CSV 파일로 내보냅니다
```

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

---

## 6. SQL을 사용한 기본 수학 및 통계

**기본 수학**

연산

- `+` (더하기)
- `-` (빼기)
- `*` (곱하기)
- `/` (나누기)
- `%` (나머지)
- `^` (거듭제곱)
- `|/` (제곱근)
- `||/` (큐브 루트)
- `||` (절대값)
- `!` (팩토리얼)

```sql
SELECT 1 + 1; -- 2
```

```sql
SELECT 1 - 1; -- 0
```

```sql
SELECT 2 * 2; -- 4
```

```sql
SELECT 4 / 2; -- 2
```

```sql
SELECT 4 % 2; -- 0
```

```sql
SELECT 2 ^ 3; -- 8
```

```sql
SELECT 2 ^ 0.5; -- 1.4142135623730951
```

```sql
SELECT 2 ^ -1; -- 0.5
```

```sql
SELECT 2 ^ 0; -- 1
```

```sql
SELECT 2 ^ NULL; -- NULL
```

```sql
SELECT 2 ^ 3 ^ 2; -- 512
```

```sql
SELECT (2 ^ 3) ^ 2; -- 64
```

```sql
SELECT 2 ^ (3 ^ 2); -- 512
```

```sql
SELECT 2 ^ 3 * 2; -- 16
```

```sql
SELECT 11 / 6;
SELECT 11 % 6;
SELECT 11.0 / 6;
SELECT CAST(11 AS numeric(3,1)) / 6;
```

```sql
SELECT 3 ^ 4;
SELECT |/ 10;
SELECT sqrt(10);
SELECT ||/ 10;
SELECT factorial(4);
SELECT 4 !;
```

**테이블에서 하는 수학**

```sql
SELECT salary * 2 AS double_salary FROM teachers; -- salary 열의 값에 2를 곱하고 열의 이름을 'double_salary'로 지정합니다
```

```sql
SELECT county_name AS county,
       state_name AS state,
       area_water::numeric / (area_land + area_water) * 100 AS pct_water
FROM us_counties_pop_est_2019
ORDER BY pct_water DESC;
```

**통계**

Tracking Percent Change / 퍼센트 변화 추적

`(new_number - old_number) / old_number * 100`

```sql
CREATE TABLE percent_change (
  department text,
  spend_2019 numeric(10,2),
  spend_2022 numeric(10,2)
);

INSERT INTO percent_change
VALUES
  ('Assessor', 178556, 179500),
  ('Building', 250000, 289000),
  ('Clerk', 451980, 650000),
  ('Library', 87777, 90001),
  ('Parks', 250000, 223000),
  ('Water', 199000, 195000);

SELECT department,
      spend_2019,
      spend_2022,
      round( (spend_2022 - spend_2019) /
                    spend_2019 * 100, 1) AS pct_change
FROM percent_change;
```

SUM / 합계

```sql
SELECT SUM(salary) FROM teachers; -- salary 열의 합을 구합니다
```

평균

```sql
SELECT AVG(salary) FROM teachers; -- salary 열의 평균을 구합니다
```

중간값

```sql
SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY salary) AS median_salary
FROM teachers; -- salary 열의 중간값을 구합니다
```

Finding Other Quantiles with Percentile Functions / 백분위수 함수를 사용하여 다른 백분위수 찾기

```sql
SELECT percentile_cont(ARRAY[.25,.5,.75])
       WITHIN GROUP (ORDER BY salary) AS quartiles
FROM teachers;
```

```sql

SELECT unnest(
    percentile_cont(ARRAY[.25,.5,.75])
    WITHIN GROUP (ORDER BY salary)
  ) AS quartiles
FROM teachers;
```

Finding the mode /

```sql

SELECT mode() WITHIN GROUP (ORDER BY births_2019)
FROM us_counties_pop_est_2019;
```

최빈값

```sql
SELECT salary, COUNT(*) AS count
FROM teachers
GROUP BY salary
ORDER BY count DESC
LIMIT 1; -- salary 열의 최빈값을 구합니다
```

표준편차

```sql
SELECT STDDEV(salary) FROM teachers; -- salary 열의 표준편차를 구합니다
```

분산

```sql
SELECT VARIANCE(salary) FROM teachers; -- salary 열의 분산을 구합니다
```

최솟값

```sql
SELECT MIN(salary) FROM teachers; -- salary 열의 최솟값을 구합니다
```

최댓값

```sql
SELECT MAX(salary) FROM teachers; -- salary 열의 최댓값을 구합니다
```

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

---

## 7. 관계형 데이터베이스에서 테이블 조인

[목차로 돌아가기](#midterm-guide--중간고사-가이드)
