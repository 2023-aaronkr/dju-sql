---
layout: page
title: Midterm Guide / 중간고사 가이드
permalink: /midterm/
---

{:toc}

---

1. [코딩 환경 설정](#1-코딩-환경-설정)
2. [데이타베이스와 테이블 생성](#2-데이타베이스와-테이블-생성)
3. [SELECT로 시작하는 데이터 탐험](#3-SELECT로-시작하는-데이터-탐험)
4. [데이터 타입 이해](#4-데이터-타입-이해)
5. [데이터 가져오고 내보내기](#5-데이터-가져오고-내보내기)
6. [SQL을 사용한 기본 수학 및 통계](#6-SQL을-사용한-기본-수학-및-통계)
7. [관계형 데이터베이스에서 테이블 조인](#7-관계형-데이터베이스에서-테이블-조인)

---

## 이 책에 대하여

1. SQL은 무엇인가?
2. 왜 SQL을 사용해야 할까?
3. 엑셀은 시트 하나당 최대 1,048,576개의 행을 생성할 수 있습니다.
4. 액세스는 데이터베이스 코개가 2GB로 제한되어 있고 테이블당 열을 255개까지만 생성할 수 있습니다.

## 1. 코딩 환경 설정

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

---

## 2. 데이타베이스와 테이블 생성

1. 테이블 이해
2. pgAdmin에서 SQL 실행

**테이블 생성**

```sql
CREATE DATABASE dju;
```

```sql
CREATE TABLE teachers (
  id bigserial, -- bigserial은 자동으로 증가하는 숫자를 생성합니다 (PostgreSQL에서만 사용 가능)
  first_name varchar(25), -- varchar는 가변 길이 문자열을 저장합니다 (예: 'Aaron')
  last_name varchar(50),
  school varchar(50),
  hire_date date, -- date는 날짜를 저장합니다 (예: YYYY-MM-DD)
  salary numeric -- numeric은 숫자를 저장합니다 (예: 123456.78)
);
```

**테이블에 행 삽입**

```sql
INSERT INTO teachers (first_name, last_name, school, hire_date, salary)
VALUES ('Aaron', 'Snowberger', 'Daejeon University', '2023-09-01', 10000),
        ('John', 'Doe', 'Daejeon University', '2023-09-01', 10000),
        ('Jane', 'Doe', 'Daejeon University', '2023-09-01', 10000);
```

**테이블 데이터 보기**

```sql
TABLE teachers; -- 테이블의 모든 열을 보여줍니다 (1번째 방법)

SELECT * FROM teachers; -- 테이블의 모든 열을 보여줍니다 (2번째 방법)
```

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

---

## 3. SELECT로 시작하는 데이터 탐험

**SELECT**

```sql
SELECT * FROM teachers; -- 테이블의 모든 열을 보여줍니다
```

**WHERE**

```sql
SELECT * FROM teachers
WHERE first_name = 'Aaron'; -- first_name이 'Aaron'인 행만 보여줍니다
```

**AND**

```sql
SELECT * FROM teachers
WHERE first_name = 'Aaron' AND last_name = 'Snowberger'; -- first_name이 'Aaron'이고 last_name이 'Snowberger'인 행만 보여줍니다
```

**OR**

```sql
SELECT * FROM teachers
WHERE first_name = 'Aaron' OR first_name = 'John'; -- first_name이 'Aaron'이거나 'John'인 행만 보여줍니다
```

**IN**

```sql
SELECT * FROM teachers
WHERE first_name IN ('Aaron', 'John'); -- first_name이 'Aaron'이거나 'John'인 행만 보여줍니다
```

**NOT**

```sql
SELECT * FROM teachers
WHERE first_name NOT IN ('Aaron', 'John'); -- first_name이 'Aaron'이거나 'John'이 아닌 행만 보여줍니다
```

**BETWEEN**

```sql
SELECT * FROM teachers
WHERE hire_date BETWEEN '2023-09-01' AND '2023-09-30'; -- hire_date가 '2023-09-01'과 '2023-09-30' 사이인 행만 보여줍니다
```

**LIKE**

```sql
SELECT * FROM teachers
WHERE first_name LIKE 'A%'; -- first_name이 'A'로 시작하는 행만 보여줍니다
```

**ILIKE**

```sql
SELECT * FROM teachers
WHERE first_name ILIKE 'a%'; -- first_name이 'a'로 시작하는 행만 보여줍니다 (대소문자 구분 없음)
```

**ORDER BY**

```sql
SELECT * FROM teachers
ORDER BY last_name; -- last_name을 오름차순으로 정렬합니다
```

```sql
SELECT * FROM teachers
ORDER BY last_name DESC; -- last_name을 내림차순으로 정렬합니다
```

**LIMIT**

```sql
SELECT * FROM teachers
LIMIT 2; -- 행을 2개만 보여줍니다
```

**DISTINCT**

```sql
SELECT DISTINCT school FROM teachers; -- school 열의 중복을 제거합니다
```

**COUNT**

```sql
SELECT COUNT(*) FROM teachers; -- 행의 개수를 세어줍니다
```

**SUM**

```sql
SELECT SUM(salary) FROM teachers; -- salary 열의 합을 구합니다
```

**AVG**

```sql
SELECT AVG(salary) FROM teachers; -- salary 열의 평균을 구합니다
```

**MIN**

```sql
SELECT MIN(salary) FROM teachers; -- salary 열의 최솟값을 구합니다
```

**MAX**

```sql
SELECT MAX(salary) FROM teachers; -- salary 열의 최댓값을 구합니다
```

**GROUP BY**

```sql
SELECT school, COUNT(*) FROM teachers
GROUP BY school; -- school 열의 중복을 제거하고 행의 개수를 세어줍니다
```

**HAVING**

```sql
SELECT school, COUNT(*) FROM teachers
GROUP BY school
HAVING COUNT(*) > 1; -- school 열의 중복을 제거하고 행의 개수가 1보다 큰 행만 보여줍니다
```

**AS**

```sql
SELECT school, COUNT(*) AS count FROM teachers
GROUP BY school
HAVING COUNT(*) > 1; -- school 열의 중복을 제거하고 행의 개수가 1보다 큰 행만 보여줍니다
```

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

---

## 4. 데이터 타입 이해

**데이터 타입**

**문자열**

- `char(n)` (입력한 n 에 따라 길)
- `varchar(n)` (최대 길이가 n)
- `text` (길이 제한이 없는 가변 길 (1GB 입니다))

**숫자**

정수

- `smallint` (2바이트)
- `integer` (4바이트)
- `bigint` (8바이트)

실수

- `numeric(10, 2)` (고정 소수점) - fixed point - 10자리 숫자 중 소수점 이하 2자리까지 정밀도
- `real` (부동 소수점) - single precision (소수점 이하 6자리까지 정밀도)
- `double precision` (부동 소수점) - double precision (소수점 이하 15자리까지 정밀도)

자동 증가

- `smallserial` (2바이트) _PostgreSQL에서만 사용 가능_
- `serial` (4바이트) _PostgreSQL에서만 사용 가능_
- `bigserial` (8바이트) _PostgreSQL에서만 사용 가능_
- `id integer GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY;` 다른 데이터베이스에서는 이렇게 사용합니다

**날짜**

- `date` (YYYY-MM-DD) (예: '2023-09-01') = 4바이트
- `time` (HH:MM:SS) (예: '12:30:00') = 8바이트
- `timestamp` (YYYY-MM-DD HH:MM:SS) (예: '2023-09-01 12:30:00') = 8바이트
- `interval` (예: '1 day') = 16바이트
- 불리언

**JSON**

- `json` (JSON 데이터) = 키/값 쌍과 값 목록의 컬렉션으로 정보를 구성하는 데이터 형식
- `jsonb` (JSON 데이터) = json과 동일하지만, 데이터가 정렬되어 있습니다 (인덱성을 지원하므로 처리 속도가 빠릅니다)

**다른 타입**

- `boolean` (true/false)
- `enum` (열거형)
- `uuid` (UUID)
- `xml` (XML 데이터)
- `range` (범위)
- `geomtric` (기하학)
- `text search` (텍스트 검색)
- `cidr` (IPv4/IPv6 네트워크 주소)
- `inet` (IPv4/IPv6 호스트 주소)
- `macaddr` (MAC 주소)
- `bit` (비트열)
- `bit varying` (가변 비트열)
- `NULL` (데이터가 없음)

**데이터 타입 변환**

```sql
SELECT CAST('2023-09-01' AS date); -- 문자열을 날짜로 변환합니다
```

```sql
SELECT CAST('2023-09-01' AS date) + 1 AS tomorrow; -- 날짜에 1을 더하고 열의 이름을 'tomorrow'로 지정합니다
```

```sql
SELECT timestamp_column, CAST(timestamp_column AS varchar(10))
FROM data_time_types; -- timestamp_column 열을 문자열로 변환합니다

SELECT timestamp_column, timestamp_column::varchar(10)
FROM data_time_types; -- 위와 동일한 결과를 보여줍니다
```

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

---

## 5. 데이터 가져오고 내보내기

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

---

## 6. SQL을 사용한 기본 수학 및 통계

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

---

## 7. 관계형 데이터베이스에서 테이블 조인

[목차로 돌아가기](#midterm-guide--중간고사-가이드)

```

```
